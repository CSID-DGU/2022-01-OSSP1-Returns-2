"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_1 = __importDefault(require("webpack"));
const webpack_dev_server_1 = __importDefault(require("webpack-dev-server"));
const detect_port_1 = __importDefault(require("detect-port"));
const inquirer_1 = require("inquirer");
const config_1 = __importDefault(require("../utils/config"));
const creator_1 = require("./creator");
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
class Dev extends creator_1.WebpackCreator {
    constructor(opts) {
        super(opts);
        const { port, host } = this.opts;
        const userDefinedDevServerConfig = config_1.default.userConf.devServer || {};
        this.devServerConf = {
            port,
            host,
            contentBase: config_1.default.defaultPaths.dist,
            historyApiFallback: true,
            disableHostCheck: true,
            compress: true,
            clientLogLevel: 'none',
            hot: true,
            inline: true,
            publicPath: '/',
            watchOptions: {
                ignored: /node_modules/,
                aggregateTimeout: 600,
            },
            ...userDefinedDevServerConfig,
        };
    }
    config() {
        const conf = {
            devtool: 'cheap-module-source-map',
            plugins: [this.opts.analyzer && new BundleAnalyzerPlugin()].filter(Boolean),
            optimization: {
                splitChunks: {
                    chunks: 'all',
                },
            },
        };
        return this.mergeConfig([this.baseConfig, conf]);
    }
    async changePort(newPort, port) {
        const question = {
            type: 'confirm',
            name: 'changePort',
            message: `port: ${port} has been usedï¼Œuse new port ${newPort} instead?`,
            default: true,
        };
        const answer = await (0, inquirer_1.prompt)([question]);
        if (answer.changePort) {
            return newPort;
        }
        else {
            return null;
        }
    }
    async checkPort(port) {
        const newPort = await (0, detect_port_1.default)(port);
        if (newPort === port) {
            return newPort;
        }
        const isInteractive = process.stdout.isTTY;
        if (isInteractive) {
            return this.changePort(newPort, port);
        }
    }
    threadLoaderWarmUp() {
        const threadLoader = require('thread-loader');
        threadLoader.warmup({}, [require.resolve('babel-loader')]);
    }
    async action() {
        const { port } = this.devServerConf;
        const newPort = await this.checkPort(port);
        if (!newPort) {
            process.exit(0);
        }
        this.devServerConf.port = newPort;
        webpack_dev_server_1.default.addDevServerEntrypoints(this.config(), this.devServerConf);
        this.threadLoaderWarmUp();
        const compiler = (0, webpack_1.default)(this.config());
        const devServer = new webpack_dev_server_1.default(compiler, this.devServerConf);
        let isFirstCompile = true;
        compiler.hooks.done.tap('done', stats => {
            if (isFirstCompile) {
                isFirstCompile = false;
                this.successStdout('development server has been started');
            }
            if (stats.hasErrors()) {
                console.log(stats.toString({
                    colors: true,
                }));
            }
        });
        devServer.listen(this.devServerConf.port, this.devServerConf.host, err => {
            if (err) {
                console.error(err);
                process.exit(1);
            }
        });
    }
}
exports.default = Dev;
